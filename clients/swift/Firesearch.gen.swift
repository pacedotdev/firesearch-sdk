//  Code generated by oto; DO NOT EDIT.

import Foundation

class OtoClient {
	var endpoint: String
	init(withEndpoint url: String) {
		self.endpoint = url
	}
}


// AccessKeyService provides keys needed to perform searches.
class AccessKeyService {
	var client: OtoClient
	init(withClient client: OtoClient) {
		self.client = client
	}

	// GenerateKey generates a key for an index path prefix to enable searches.
	func generateKey(withRequest generateKeyRequest: GenerateKeyRequest, completion: @escaping (_ response: GenerateKeyResponse?, _ error: Error?) -> ()) {
		let url = "\(self.client.endpoint)/AccessKeyService.GenerateKey"
		var request = URLRequest(url: URL(string: url)!)
		request.httpMethod = "POST"
		request.addValue("application/json; charset=utf-8", forHTTPHeaderField: "Content-Type")
		request.addValue("application/json; charset=utf-8", forHTTPHeaderField: "Accept")
		var jsonData: Data
		do {
			jsonData = try JSONEncoder().encode(generateKeyRequest)
		} catch let err {
			completion(nil, err)
			return
		}
		request.httpBody = jsonData
		let session = URLSession(configuration: URLSessionConfiguration.default)
		let task = session.dataTask(with: request) { (data, response, error) in
			if let err = error {
				completion(nil, err)
				return
			}
			if let httpResponse = response as? HTTPURLResponse {
				if (httpResponse.statusCode != 200) {
					let err = OtoError("\(url): \(httpResponse.statusCode) status code")
					completion(nil, err)
					return
				}
			}
			var generateKeyResponse: GenerateKeyResponse
			do {
				generateKeyResponse = try JSONDecoder().decode(GenerateKeyResponse.self, from: data!)
			} catch let err {
				completion(nil, err)
				return
			}
			completion(generateKeyResponse, nil)
		}
		task.resume()
	}

}

// AutocompleteService provides the ability to create and manage autocomplete
// indexes, as well as populate them with data, and perform lookups.
class AutocompleteService {
	var client: OtoClient
	init(withClient client: OtoClient) {
		self.client = client
	}

	// CheckIndexName checks to see if an index name is available or not.
	func checkIndexName(withRequest checkAutocompleteIndexNameRequest: CheckAutocompleteIndexNameRequest, completion: @escaping (_ response: CheckAutocompleteIndexNameResponse?, _ error: Error?) -> ()) {
		let url = "\(self.client.endpoint)/AutocompleteService.CheckIndexName"
		var request = URLRequest(url: URL(string: url)!)
		request.httpMethod = "POST"
		request.addValue("application/json; charset=utf-8", forHTTPHeaderField: "Content-Type")
		request.addValue("application/json; charset=utf-8", forHTTPHeaderField: "Accept")
		var jsonData: Data
		do {
			jsonData = try JSONEncoder().encode(checkAutocompleteIndexNameRequest)
		} catch let err {
			completion(nil, err)
			return
		}
		request.httpBody = jsonData
		let session = URLSession(configuration: URLSessionConfiguration.default)
		let task = session.dataTask(with: request) { (data, response, error) in
			if let err = error {
				completion(nil, err)
				return
			}
			if let httpResponse = response as? HTTPURLResponse {
				if (httpResponse.statusCode != 200) {
					let err = OtoError("\(url): \(httpResponse.statusCode) status code")
					completion(nil, err)
					return
				}
			}
			var checkAutocompleteIndexNameResponse: CheckAutocompleteIndexNameResponse
			do {
				checkAutocompleteIndexNameResponse = try JSONDecoder().decode(CheckAutocompleteIndexNameResponse.self, from: data!)
			} catch let err {
				completion(nil, err)
				return
			}
			completion(checkAutocompleteIndexNameResponse, nil)
		}
		task.resume()
	}

	// CheckIndexPath checks to see if an AutocompleteIndexPath is valid for creating
// an index.
	func checkIndexPath(withRequest checkAutocompleteIndexPathRequest: CheckAutocompleteIndexPathRequest, completion: @escaping (_ response: CheckAutocompleteIndexPathResponse?, _ error: Error?) -> ()) {
		let url = "\(self.client.endpoint)/AutocompleteService.CheckIndexPath"
		var request = URLRequest(url: URL(string: url)!)
		request.httpMethod = "POST"
		request.addValue("application/json; charset=utf-8", forHTTPHeaderField: "Content-Type")
		request.addValue("application/json; charset=utf-8", forHTTPHeaderField: "Accept")
		var jsonData: Data
		do {
			jsonData = try JSONEncoder().encode(checkAutocompleteIndexPathRequest)
		} catch let err {
			completion(nil, err)
			return
		}
		request.httpBody = jsonData
		let session = URLSession(configuration: URLSessionConfiguration.default)
		let task = session.dataTask(with: request) { (data, response, error) in
			if let err = error {
				completion(nil, err)
				return
			}
			if let httpResponse = response as? HTTPURLResponse {
				if (httpResponse.statusCode != 200) {
					let err = OtoError("\(url): \(httpResponse.statusCode) status code")
					completion(nil, err)
					return
				}
			}
			var checkAutocompleteIndexPathResponse: CheckAutocompleteIndexPathResponse
			do {
				checkAutocompleteIndexPathResponse = try JSONDecoder().decode(CheckAutocompleteIndexPathResponse.self, from: data!)
			} catch let err {
				completion(nil, err)
				return
			}
			completion(checkAutocompleteIndexPathResponse, nil)
		}
		task.resume()
	}

	// Complete performs a search on an AutocompleteIndex.
	func complete(withRequest completeRequest: CompleteRequest, completion: @escaping (_ response: CompleteResponse?, _ error: Error?) -> ()) {
		let url = "\(self.client.endpoint)/AutocompleteService.Complete"
		var request = URLRequest(url: URL(string: url)!)
		request.httpMethod = "POST"
		request.addValue("application/json; charset=utf-8", forHTTPHeaderField: "Content-Type")
		request.addValue("application/json; charset=utf-8", forHTTPHeaderField: "Accept")
		var jsonData: Data
		do {
			jsonData = try JSONEncoder().encode(completeRequest)
		} catch let err {
			completion(nil, err)
			return
		}
		request.httpBody = jsonData
		let session = URLSession(configuration: URLSessionConfiguration.default)
		let task = session.dataTask(with: request) { (data, response, error) in
			if let err = error {
				completion(nil, err)
				return
			}
			if let httpResponse = response as? HTTPURLResponse {
				if (httpResponse.statusCode != 200) {
					let err = OtoError("\(url): \(httpResponse.statusCode) status code")
					completion(nil, err)
					return
				}
			}
			var completeResponse: CompleteResponse
			do {
				completeResponse = try JSONDecoder().decode(CompleteResponse.self, from: data!)
			} catch let err {
				completion(nil, err)
				return
			}
			completion(completeResponse, nil)
		}
		task.resume()
	}

	// CreateIndex creates a new index.
	func createIndex(withRequest createAutocompleteIndexRequest: CreateAutocompleteIndexRequest, completion: @escaping (_ response: CreateAutocompleteIndexResponse?, _ error: Error?) -> ()) {
		let url = "\(self.client.endpoint)/AutocompleteService.CreateIndex"
		var request = URLRequest(url: URL(string: url)!)
		request.httpMethod = "POST"
		request.addValue("application/json; charset=utf-8", forHTTPHeaderField: "Content-Type")
		request.addValue("application/json; charset=utf-8", forHTTPHeaderField: "Accept")
		var jsonData: Data
		do {
			jsonData = try JSONEncoder().encode(createAutocompleteIndexRequest)
		} catch let err {
			completion(nil, err)
			return
		}
		request.httpBody = jsonData
		let session = URLSession(configuration: URLSessionConfiguration.default)
		let task = session.dataTask(with: request) { (data, response, error) in
			if let err = error {
				completion(nil, err)
				return
			}
			if let httpResponse = response as? HTTPURLResponse {
				if (httpResponse.statusCode != 200) {
					let err = OtoError("\(url): \(httpResponse.statusCode) status code")
					completion(nil, err)
					return
				}
			}
			var createAutocompleteIndexResponse: CreateAutocompleteIndexResponse
			do {
				createAutocompleteIndexResponse = try JSONDecoder().decode(CreateAutocompleteIndexResponse.self, from: data!)
			} catch let err {
				completion(nil, err)
				return
			}
			completion(createAutocompleteIndexResponse, nil)
		}
		task.resume()
	}

	// DeleteDoc removes a document from an AutocompleteIndex. Once deleted, it will
// stop appearing in search results.
	func deleteDoc(withRequest deleteAutocompleteDocRequest: DeleteAutocompleteDocRequest, completion: @escaping (_ response: DeleteAutocompleteDocResponse?, _ error: Error?) -> ()) {
		let url = "\(self.client.endpoint)/AutocompleteService.DeleteDoc"
		var request = URLRequest(url: URL(string: url)!)
		request.httpMethod = "POST"
		request.addValue("application/json; charset=utf-8", forHTTPHeaderField: "Content-Type")
		request.addValue("application/json; charset=utf-8", forHTTPHeaderField: "Accept")
		var jsonData: Data
		do {
			jsonData = try JSONEncoder().encode(deleteAutocompleteDocRequest)
		} catch let err {
			completion(nil, err)
			return
		}
		request.httpBody = jsonData
		let session = URLSession(configuration: URLSessionConfiguration.default)
		let task = session.dataTask(with: request) { (data, response, error) in
			if let err = error {
				completion(nil, err)
				return
			}
			if let httpResponse = response as? HTTPURLResponse {
				if (httpResponse.statusCode != 200) {
					let err = OtoError("\(url): \(httpResponse.statusCode) status code")
					completion(nil, err)
					return
				}
			}
			var deleteAutocompleteDocResponse: DeleteAutocompleteDocResponse
			do {
				deleteAutocompleteDocResponse = try JSONDecoder().decode(DeleteAutocompleteDocResponse.self, from: data!)
			} catch let err {
				completion(nil, err)
				return
			}
			completion(deleteAutocompleteDocResponse, nil)
		}
		task.resume()
	}

	// DeleteIndex deletes the AutocompleteIndex. All index data, as well as any
// metadata about this AutocompleteIndex will be completely deleted.
	func deleteIndex(withRequest deleteAutocompleteIndexRequest: DeleteAutocompleteIndexRequest, completion: @escaping (_ response: DeleteAutocompleteIndexResponse?, _ error: Error?) -> ()) {
		let url = "\(self.client.endpoint)/AutocompleteService.DeleteIndex"
		var request = URLRequest(url: URL(string: url)!)
		request.httpMethod = "POST"
		request.addValue("application/json; charset=utf-8", forHTTPHeaderField: "Content-Type")
		request.addValue("application/json; charset=utf-8", forHTTPHeaderField: "Accept")
		var jsonData: Data
		do {
			jsonData = try JSONEncoder().encode(deleteAutocompleteIndexRequest)
		} catch let err {
			completion(nil, err)
			return
		}
		request.httpBody = jsonData
		let session = URLSession(configuration: URLSessionConfiguration.default)
		let task = session.dataTask(with: request) { (data, response, error) in
			if let err = error {
				completion(nil, err)
				return
			}
			if let httpResponse = response as? HTTPURLResponse {
				if (httpResponse.statusCode != 200) {
					let err = OtoError("\(url): \(httpResponse.statusCode) status code")
					completion(nil, err)
					return
				}
			}
			var deleteAutocompleteIndexResponse: DeleteAutocompleteIndexResponse
			do {
				deleteAutocompleteIndexResponse = try JSONDecoder().decode(DeleteAutocompleteIndexResponse.self, from: data!)
			} catch let err {
				completion(nil, err)
				return
			}
			completion(deleteAutocompleteIndexResponse, nil)
		}
		task.resume()
	}

	// GetIndex gets an AutocompleteIndex.
	func getIndex(withRequest getAutocompleteIndexRequest: GetAutocompleteIndexRequest, completion: @escaping (_ response: GetAutocompleteIndexResponse?, _ error: Error?) -> ()) {
		let url = "\(self.client.endpoint)/AutocompleteService.GetIndex"
		var request = URLRequest(url: URL(string: url)!)
		request.httpMethod = "POST"
		request.addValue("application/json; charset=utf-8", forHTTPHeaderField: "Content-Type")
		request.addValue("application/json; charset=utf-8", forHTTPHeaderField: "Accept")
		var jsonData: Data
		do {
			jsonData = try JSONEncoder().encode(getAutocompleteIndexRequest)
		} catch let err {
			completion(nil, err)
			return
		}
		request.httpBody = jsonData
		let session = URLSession(configuration: URLSessionConfiguration.default)
		let task = session.dataTask(with: request) { (data, response, error) in
			if let err = error {
				completion(nil, err)
				return
			}
			if let httpResponse = response as? HTTPURLResponse {
				if (httpResponse.statusCode != 200) {
					let err = OtoError("\(url): \(httpResponse.statusCode) status code")
					completion(nil, err)
					return
				}
			}
			var getAutocompleteIndexResponse: GetAutocompleteIndexResponse
			do {
				getAutocompleteIndexResponse = try JSONDecoder().decode(GetAutocompleteIndexResponse.self, from: data!)
			} catch let err {
				completion(nil, err)
				return
			}
			completion(getAutocompleteIndexResponse, nil)
		}
		task.resume()
	}

	// GetIndexes gets a list of AutocompleteIndexes.
	func getIndexes(withRequest getAutocompleteIndexesRequest: GetAutocompleteIndexesRequest, completion: @escaping (_ response: GetAutocompleteIndexesResponse?, _ error: Error?) -> ()) {
		let url = "\(self.client.endpoint)/AutocompleteService.GetIndexes"
		var request = URLRequest(url: URL(string: url)!)
		request.httpMethod = "POST"
		request.addValue("application/json; charset=utf-8", forHTTPHeaderField: "Content-Type")
		request.addValue("application/json; charset=utf-8", forHTTPHeaderField: "Accept")
		var jsonData: Data
		do {
			jsonData = try JSONEncoder().encode(getAutocompleteIndexesRequest)
		} catch let err {
			completion(nil, err)
			return
		}
		request.httpBody = jsonData
		let session = URLSession(configuration: URLSessionConfiguration.default)
		let task = session.dataTask(with: request) { (data, response, error) in
			if let err = error {
				completion(nil, err)
				return
			}
			if let httpResponse = response as? HTTPURLResponse {
				if (httpResponse.statusCode != 200) {
					let err = OtoError("\(url): \(httpResponse.statusCode) status code")
					completion(nil, err)
					return
				}
			}
			var getAutocompleteIndexesResponse: GetAutocompleteIndexesResponse
			do {
				getAutocompleteIndexesResponse = try JSONDecoder().decode(GetAutocompleteIndexesResponse.self, from: data!)
			} catch let err {
				completion(nil, err)
				return
			}
			completion(getAutocompleteIndexesResponse, nil)
		}
		task.resume()
	}

	// PutDoc puts a document into an AutocompleteIndex.
	func putDoc(withRequest putAutocompleteDocRequest: PutAutocompleteDocRequest, completion: @escaping (_ response: PutAutocompleteDocResponse?, _ error: Error?) -> ()) {
		let url = "\(self.client.endpoint)/AutocompleteService.PutDoc"
		var request = URLRequest(url: URL(string: url)!)
		request.httpMethod = "POST"
		request.addValue("application/json; charset=utf-8", forHTTPHeaderField: "Content-Type")
		request.addValue("application/json; charset=utf-8", forHTTPHeaderField: "Accept")
		var jsonData: Data
		do {
			jsonData = try JSONEncoder().encode(putAutocompleteDocRequest)
		} catch let err {
			completion(nil, err)
			return
		}
		request.httpBody = jsonData
		let session = URLSession(configuration: URLSessionConfiguration.default)
		let task = session.dataTask(with: request) { (data, response, error) in
			if let err = error {
				completion(nil, err)
				return
			}
			if let httpResponse = response as? HTTPURLResponse {
				if (httpResponse.statusCode != 200) {
					let err = OtoError("\(url): \(httpResponse.statusCode) status code")
					completion(nil, err)
					return
				}
			}
			var putAutocompleteDocResponse: PutAutocompleteDocResponse
			do {
				putAutocompleteDocResponse = try JSONDecoder().decode(PutAutocompleteDocResponse.self, from: data!)
			} catch let err {
				completion(nil, err)
				return
			}
			completion(putAutocompleteDocResponse, nil)
		}
		task.resume()
	}

}

// IndexService provides the ability to create and manage full-text indexes, as
// well as populate them with data, and perform searches.
class IndexService {
	var client: OtoClient
	init(withClient client: OtoClient) {
		self.client = client
	}

	// CheckIndexName checks to see if an index name is available or not.
	func checkIndexName(withRequest checkIndexNameRequest: CheckIndexNameRequest, completion: @escaping (_ response: CheckIndexNameResponse?, _ error: Error?) -> ()) {
		let url = "\(self.client.endpoint)/IndexService.CheckIndexName"
		var request = URLRequest(url: URL(string: url)!)
		request.httpMethod = "POST"
		request.addValue("application/json; charset=utf-8", forHTTPHeaderField: "Content-Type")
		request.addValue("application/json; charset=utf-8", forHTTPHeaderField: "Accept")
		var jsonData: Data
		do {
			jsonData = try JSONEncoder().encode(checkIndexNameRequest)
		} catch let err {
			completion(nil, err)
			return
		}
		request.httpBody = jsonData
		let session = URLSession(configuration: URLSessionConfiguration.default)
		let task = session.dataTask(with: request) { (data, response, error) in
			if let err = error {
				completion(nil, err)
				return
			}
			if let httpResponse = response as? HTTPURLResponse {
				if (httpResponse.statusCode != 200) {
					let err = OtoError("\(url): \(httpResponse.statusCode) status code")
					completion(nil, err)
					return
				}
			}
			var checkIndexNameResponse: CheckIndexNameResponse
			do {
				checkIndexNameResponse = try JSONDecoder().decode(CheckIndexNameResponse.self, from: data!)
			} catch let err {
				completion(nil, err)
				return
			}
			completion(checkIndexNameResponse, nil)
		}
		task.resume()
	}

	// CheckIndexPath checks to see if an IndexPath is valid for creating an index.
	func checkIndexPath(withRequest checkIndexPathRequest: CheckIndexPathRequest, completion: @escaping (_ response: CheckIndexPathResponse?, _ error: Error?) -> ()) {
		let url = "\(self.client.endpoint)/IndexService.CheckIndexPath"
		var request = URLRequest(url: URL(string: url)!)
		request.httpMethod = "POST"
		request.addValue("application/json; charset=utf-8", forHTTPHeaderField: "Content-Type")
		request.addValue("application/json; charset=utf-8", forHTTPHeaderField: "Accept")
		var jsonData: Data
		do {
			jsonData = try JSONEncoder().encode(checkIndexPathRequest)
		} catch let err {
			completion(nil, err)
			return
		}
		request.httpBody = jsonData
		let session = URLSession(configuration: URLSessionConfiguration.default)
		let task = session.dataTask(with: request) { (data, response, error) in
			if let err = error {
				completion(nil, err)
				return
			}
			if let httpResponse = response as? HTTPURLResponse {
				if (httpResponse.statusCode != 200) {
					let err = OtoError("\(url): \(httpResponse.statusCode) status code")
					completion(nil, err)
					return
				}
			}
			var checkIndexPathResponse: CheckIndexPathResponse
			do {
				checkIndexPathResponse = try JSONDecoder().decode(CheckIndexPathResponse.self, from: data!)
			} catch let err {
				completion(nil, err)
				return
			}
			completion(checkIndexPathResponse, nil)
		}
		task.resume()
	}

	// CreateIndex creates a new index.
	func createIndex(withRequest createIndexRequest: CreateIndexRequest, completion: @escaping (_ response: CreateIndexResponse?, _ error: Error?) -> ()) {
		let url = "\(self.client.endpoint)/IndexService.CreateIndex"
		var request = URLRequest(url: URL(string: url)!)
		request.httpMethod = "POST"
		request.addValue("application/json; charset=utf-8", forHTTPHeaderField: "Content-Type")
		request.addValue("application/json; charset=utf-8", forHTTPHeaderField: "Accept")
		var jsonData: Data
		do {
			jsonData = try JSONEncoder().encode(createIndexRequest)
		} catch let err {
			completion(nil, err)
			return
		}
		request.httpBody = jsonData
		let session = URLSession(configuration: URLSessionConfiguration.default)
		let task = session.dataTask(with: request) { (data, response, error) in
			if let err = error {
				completion(nil, err)
				return
			}
			if let httpResponse = response as? HTTPURLResponse {
				if (httpResponse.statusCode != 200) {
					let err = OtoError("\(url): \(httpResponse.statusCode) status code")
					completion(nil, err)
					return
				}
			}
			var createIndexResponse: CreateIndexResponse
			do {
				createIndexResponse = try JSONDecoder().decode(CreateIndexResponse.self, from: data!)
			} catch let err {
				completion(nil, err)
				return
			}
			completion(createIndexResponse, nil)
		}
		task.resume()
	}

	// DeleteDoc removes a document from an Index. Once deleted, it will stop appearing
// in search results.
	func deleteDoc(withRequest deleteDocRequest: DeleteDocRequest, completion: @escaping (_ response: DeleteDocResponse?, _ error: Error?) -> ()) {
		let url = "\(self.client.endpoint)/IndexService.DeleteDoc"
		var request = URLRequest(url: URL(string: url)!)
		request.httpMethod = "POST"
		request.addValue("application/json; charset=utf-8", forHTTPHeaderField: "Content-Type")
		request.addValue("application/json; charset=utf-8", forHTTPHeaderField: "Accept")
		var jsonData: Data
		do {
			jsonData = try JSONEncoder().encode(deleteDocRequest)
		} catch let err {
			completion(nil, err)
			return
		}
		request.httpBody = jsonData
		let session = URLSession(configuration: URLSessionConfiguration.default)
		let task = session.dataTask(with: request) { (data, response, error) in
			if let err = error {
				completion(nil, err)
				return
			}
			if let httpResponse = response as? HTTPURLResponse {
				if (httpResponse.statusCode != 200) {
					let err = OtoError("\(url): \(httpResponse.statusCode) status code")
					completion(nil, err)
					return
				}
			}
			var deleteDocResponse: DeleteDocResponse
			do {
				deleteDocResponse = try JSONDecoder().decode(DeleteDocResponse.self, from: data!)
			} catch let err {
				completion(nil, err)
				return
			}
			completion(deleteDocResponse, nil)
		}
		task.resume()
	}

	// DeleteIndex deletes the Index. All index data, as well as any metadata about
// this Index will be completely deleted.
	func deleteIndex(withRequest deleteIndexRequest: DeleteIndexRequest, completion: @escaping (_ response: DeleteIndexResponse?, _ error: Error?) -> ()) {
		let url = "\(self.client.endpoint)/IndexService.DeleteIndex"
		var request = URLRequest(url: URL(string: url)!)
		request.httpMethod = "POST"
		request.addValue("application/json; charset=utf-8", forHTTPHeaderField: "Content-Type")
		request.addValue("application/json; charset=utf-8", forHTTPHeaderField: "Accept")
		var jsonData: Data
		do {
			jsonData = try JSONEncoder().encode(deleteIndexRequest)
		} catch let err {
			completion(nil, err)
			return
		}
		request.httpBody = jsonData
		let session = URLSession(configuration: URLSessionConfiguration.default)
		let task = session.dataTask(with: request) { (data, response, error) in
			if let err = error {
				completion(nil, err)
				return
			}
			if let httpResponse = response as? HTTPURLResponse {
				if (httpResponse.statusCode != 200) {
					let err = OtoError("\(url): \(httpResponse.statusCode) status code")
					completion(nil, err)
					return
				}
			}
			var deleteIndexResponse: DeleteIndexResponse
			do {
				deleteIndexResponse = try JSONDecoder().decode(DeleteIndexResponse.self, from: data!)
			} catch let err {
				completion(nil, err)
				return
			}
			completion(deleteIndexResponse, nil)
		}
		task.resume()
	}

	// GetIndex gets an Index.
	func getIndex(withRequest getIndexRequest: GetIndexRequest, completion: @escaping (_ response: GetIndexResponse?, _ error: Error?) -> ()) {
		let url = "\(self.client.endpoint)/IndexService.GetIndex"
		var request = URLRequest(url: URL(string: url)!)
		request.httpMethod = "POST"
		request.addValue("application/json; charset=utf-8", forHTTPHeaderField: "Content-Type")
		request.addValue("application/json; charset=utf-8", forHTTPHeaderField: "Accept")
		var jsonData: Data
		do {
			jsonData = try JSONEncoder().encode(getIndexRequest)
		} catch let err {
			completion(nil, err)
			return
		}
		request.httpBody = jsonData
		let session = URLSession(configuration: URLSessionConfiguration.default)
		let task = session.dataTask(with: request) { (data, response, error) in
			if let err = error {
				completion(nil, err)
				return
			}
			if let httpResponse = response as? HTTPURLResponse {
				if (httpResponse.statusCode != 200) {
					let err = OtoError("\(url): \(httpResponse.statusCode) status code")
					completion(nil, err)
					return
				}
			}
			var getIndexResponse: GetIndexResponse
			do {
				getIndexResponse = try JSONDecoder().decode(GetIndexResponse.self, from: data!)
			} catch let err {
				completion(nil, err)
				return
			}
			completion(getIndexResponse, nil)
		}
		task.resume()
	}

	// GetIndexes gets a list of Indexes.
	func getIndexes(withRequest getIndexesRequest: GetIndexesRequest, completion: @escaping (_ response: GetIndexesResponse?, _ error: Error?) -> ()) {
		let url = "\(self.client.endpoint)/IndexService.GetIndexes"
		var request = URLRequest(url: URL(string: url)!)
		request.httpMethod = "POST"
		request.addValue("application/json; charset=utf-8", forHTTPHeaderField: "Content-Type")
		request.addValue("application/json; charset=utf-8", forHTTPHeaderField: "Accept")
		var jsonData: Data
		do {
			jsonData = try JSONEncoder().encode(getIndexesRequest)
		} catch let err {
			completion(nil, err)
			return
		}
		request.httpBody = jsonData
		let session = URLSession(configuration: URLSessionConfiguration.default)
		let task = session.dataTask(with: request) { (data, response, error) in
			if let err = error {
				completion(nil, err)
				return
			}
			if let httpResponse = response as? HTTPURLResponse {
				if (httpResponse.statusCode != 200) {
					let err = OtoError("\(url): \(httpResponse.statusCode) status code")
					completion(nil, err)
					return
				}
			}
			var getIndexesResponse: GetIndexesResponse
			do {
				getIndexesResponse = try JSONDecoder().decode(GetIndexesResponse.self, from: data!)
			} catch let err {
				completion(nil, err)
				return
			}
			completion(getIndexesResponse, nil)
		}
		task.resume()
	}

	// PutDoc puts a document into an Index.
	func putDoc(withRequest putDocRequest: PutDocRequest, completion: @escaping (_ response: PutDocResponse?, _ error: Error?) -> ()) {
		let url = "\(self.client.endpoint)/IndexService.PutDoc"
		var request = URLRequest(url: URL(string: url)!)
		request.httpMethod = "POST"
		request.addValue("application/json; charset=utf-8", forHTTPHeaderField: "Content-Type")
		request.addValue("application/json; charset=utf-8", forHTTPHeaderField: "Accept")
		var jsonData: Data
		do {
			jsonData = try JSONEncoder().encode(putDocRequest)
		} catch let err {
			completion(nil, err)
			return
		}
		request.httpBody = jsonData
		let session = URLSession(configuration: URLSessionConfiguration.default)
		let task = session.dataTask(with: request) { (data, response, error) in
			if let err = error {
				completion(nil, err)
				return
			}
			if let httpResponse = response as? HTTPURLResponse {
				if (httpResponse.statusCode != 200) {
					let err = OtoError("\(url): \(httpResponse.statusCode) status code")
					completion(nil, err)
					return
				}
			}
			var putDocResponse: PutDocResponse
			do {
				putDocResponse = try JSONDecoder().decode(PutDocResponse.self, from: data!)
			} catch let err {
				completion(nil, err)
				return
			}
			completion(putDocResponse, nil)
		}
		task.resume()
	}

	// Search performs a search on an Index.
	func search(withRequest searchRequest: SearchRequest, completion: @escaping (_ response: SearchResponse?, _ error: Error?) -> ()) {
		let url = "\(self.client.endpoint)/IndexService.Search"
		var request = URLRequest(url: URL(string: url)!)
		request.httpMethod = "POST"
		request.addValue("application/json; charset=utf-8", forHTTPHeaderField: "Content-Type")
		request.addValue("application/json; charset=utf-8", forHTTPHeaderField: "Accept")
		var jsonData: Data
		do {
			jsonData = try JSONEncoder().encode(searchRequest)
		} catch let err {
			completion(nil, err)
			return
		}
		request.httpBody = jsonData
		let session = URLSession(configuration: URLSessionConfiguration.default)
		let task = session.dataTask(with: request) { (data, response, error) in
			if let err = error {
				completion(nil, err)
				return
			}
			if let httpResponse = response as? HTTPURLResponse {
				if (httpResponse.statusCode != 200) {
					let err = OtoError("\(url): \(httpResponse.statusCode) status code")
					completion(nil, err)
					return
				}
			}
			var searchResponse: SearchResponse
			do {
				searchResponse = try JSONDecoder().decode(SearchResponse.self, from: data!)
			} catch let err {
				completion(nil, err)
				return
			}
			completion(searchResponse, nil)
		}
		task.resume()
	}

}



// GenerateKeyRequest is the input object for GenerateKey.
struct GenerateKeyRequest: Encodable, Decodable {

	// IndexPathPrefix is the collection path prefix in Firestore to provide access
// for. For example, if you put the prefix "firesearch/orgs/my-org" you will be
// able to perform searches on both "firesearch/orgs/my-org/cards" and
// "firesearch/orgs/my-org/messages" indexes.
	var indexPathPrefix: String?

}

// GenerateKeyResponse is the output object for GenerateKey.
struct GenerateKeyResponse: Encodable, Decodable {

	// AccessKey is the string that you have to pass to Search or Complete methods, to
// be able to perform searches.
	var accessKey: String?

	// Error is string explaining what went wrong. Empty if everything was fine.
	var error: String?

}

// Field is a field that can be filtered.
struct Field: Encodable, Decodable {

	// Key is the name of the field.
	var key: String?

	// Value is the filterable value of this Field.
	var value: Any?

}

// AutocompleteDoc describes a document that can be searched.
struct AutocompleteDoc: Encodable, Decodable {

	// ID is the document identifier.
	var id: String?

	// Text is a string that can be completed via a call to Complete.
	var text: String?

	// Fields are the filterable fields for this document.
	var fields: Any?

}

// AutocompleteIndex describes a search index.
struct AutocompleteIndex: Encodable, Decodable {

	// IndexPath is the collection path in Firestore for this index. Each index must
// use a unique path.
	var indexPath: String?

	// Name is an internal human readable name for this index. End users will never see
// this.
	var name: String?

	// CaseSensitive preserves case across this index. By default, all entries and
// queries are lowercased.
	var caseSensitive: Bool?

}

// CheckAutocompleteIndexNameRequest is the input for CheckAutocompleteIndexPath.
struct CheckAutocompleteIndexNameRequest: Encodable, Decodable {

	// IndexName is the name of the index to check.
	var indexName: String?

}

// ValidationResult describes the result of a validation check.
struct ValidationResult: Encodable, Decodable {

	// Valid indicates whether the validation was successful or not.
	var valid: Bool?

	// Message is a human readable objection, or empty if valid.
	var message: String?

}

// CheckAutocompleteIndexNameResponse is the output for CheckAutocompleteIndexName.
struct CheckAutocompleteIndexNameResponse: Encodable, Decodable {

	// ValidationResult holds the result of the check.
	var validationResult: Any?

	// Error is string explaining what went wrong. Empty if everything was fine.
	var error: String?

}

// CheckAutocompleteIndexPathRequest is the input object for
// CheckAutocompleteIndexPath.
struct CheckAutocompleteIndexPathRequest: Encodable, Decodable {

		var indexPath: String?

}

// CheckAutocompleteIndexPathResponse is the output for CheckAutocompleteIndexPath.
struct CheckAutocompleteIndexPathResponse: Encodable, Decodable {

	// ValidationResult holds the result of the check.
	var validationResult: Any?

	// Error is string explaining what went wrong. Empty if everything was fine.
	var error: String?

}

// CompleteQuery describes a search query.
struct CompleteQuery: Encodable, Decodable {

	// IndexPath is the path of the index to search.
	var indexPath: String?

	// AccessKey authenticates the request. Get an AccessKey from the
// AccessKeyService.GenerateKey method.
	var accessKey: String?

	// Limit is the maximum number of search results to return. Smaller limits are
// faster.
	var limit: Double?

	// Text contains a phrase to autocomplete.
	var text: String?

}

// CompleteRequest is the input object for Search.
struct CompleteRequest: Encodable, Decodable {

	// Query is the CompleteQuery to perform.
	var query: Any?

}

// CompleteResponse is the output object for Search.
struct CompleteResponse: Encodable, Decodable {

	// Query is the CompleteQuery that generated these results.
	var query: Any?

	// Hits are the search results.
	var hits: Any?

	// Duration is the milliseconds that the search took to execute in the server side
	var duration: Double?

	// Error is string explaining what went wrong. Empty if everything was fine.
	var error: String?

}

// CreateAutocompleteIndexRequest is the input object for CreateAutocompleteIndex.
struct CreateAutocompleteIndexRequest: Encodable, Decodable {

	// Index is the AutocompleteIndex to create.
	var index: Any?

}

// CreateAutocompleteIndexResponse is the output object for
// CreateAutocompleteIndex.
struct CreateAutocompleteIndexResponse: Encodable, Decodable {

	// Index is the AutocompleteIndex that was created.
	var index: Any?

	// Error is string explaining what went wrong. Empty if everything was fine.
	var error: String?

}

// DeleteAutocompleteDocRequest is the input object for DeleteAutocompleteDoc.
struct DeleteAutocompleteDocRequest: Encodable, Decodable {

	// IndexPath is the AutocompleteIndex to delete from.
	var indexPath: String?

	// ID is the identifier of the document to delete.
	var id: String?

}

// DeleteAutocompleteDocResponse is the output object for DeleteAutocompleteDoc.
struct DeleteAutocompleteDocResponse: Encodable, Decodable {

	// Error is string explaining what went wrong. Empty if everything was fine.
	var error: String?

}

// DeleteAutocompleteIndexRequest is the input object for DeleteAutocompleteIndex.
struct DeleteAutocompleteIndexRequest: Encodable, Decodable {

	// IndexPath is the collection path in Firestore that identifies an
// AutocompleteIndex.
	var indexPath: String?

}

// DeleteAutocompleteIndexResponse is the output object for
// DeleteAutocompleteIndex.
struct DeleteAutocompleteIndexResponse: Encodable, Decodable {

	// Error is string explaining what went wrong. Empty if everything was fine.
	var error: String?

}

// GetAutocompleteIndexRequest is the input object for GetAutocompleteIndex.
struct GetAutocompleteIndexRequest: Encodable, Decodable {

	// IndexPath is the collection path in Firestore that identifies an
// AutocompleteIndex.
	var indexPath: String?

}

// GetAutocompleteIndexResponse is the output object for GetAutocompleteIndex.
struct GetAutocompleteIndexResponse: Encodable, Decodable {

	// Index is the AutocompleteIndex that was created.
	var index: Any?

	// Error is string explaining what went wrong. Empty if everything was fine.
	var error: String?

}

// GetAutocompleteIndexesRequest is the input object for GetAutocompleteIndexes.
struct GetAutocompleteIndexesRequest: Encodable, Decodable {

}

// GetAutocompleteIndexesResponse is the output object for GetAutocompleteIndexes.
struct GetAutocompleteIndexesResponse: Encodable, Decodable {

	// Indexes are the indexes managed by this service.
	var indexes: Any?

	// Error is string explaining what went wrong. Empty if everything was fine.
	var error: String?

}

// PutAutocompleteDocRequest is the input object for PutAutocompleteDoc.
struct PutAutocompleteDocRequest: Encodable, Decodable {

	// IndexPath is the AutocompleteIndex to put a document to.
	var indexPath: String?

	// Doc is the document to put.
	var doc: Any?

}

// PutAutocompleteDocResponse is the output object for PutAutocompleteDoc.
struct PutAutocompleteDocResponse: Encodable, Decodable {

	// Error is string explaining what went wrong. Empty if everything was fine.
	var error: String?

}

// CheckIndexNameRequest is the input for CheckIndexPath.
struct CheckIndexNameRequest: Encodable, Decodable {

	// IndexName is the name of the index to check.
	var indexName: String?

}

// CheckIndexNameResponse is the output for CheckIndexName.
struct CheckIndexNameResponse: Encodable, Decodable {

	// ValidationResult holds the result of the check.
	var validationResult: Any?

	// Error is string explaining what went wrong. Empty if everything was fine.
	var error: String?

}

// CheckIndexPathRequest is the input object for CheckIndexPath.
struct CheckIndexPathRequest: Encodable, Decodable {

		var indexPath: String?

}

// CheckIndexPathResponse is the output for CheckIndexPath.
struct CheckIndexPathResponse: Encodable, Decodable {

	// ValidationResult holds the result of the check.
	var validationResult: Any?

	// Error is string explaining what went wrong. Empty if everything was fine.
	var error: String?

}

// Index describes a search index.
struct Index: Encodable, Decodable {

	// IndexPath is the collection path in Firestore for this index. Each index must
// use a unique path.
	var indexPath: String?

	// Name is an internal human readable name for this index. End users will never see
// this.
	var name: String?

	// Language of the index.
	var language: String?

	// KeepStopWords prevents stop words from being removed from this index.
	var keepStopWords: Bool?

	// CaseSensitive preserves case across this index. By default, all entries and
// queries are lowercased.
	var caseSensitive: Bool?

	// NoStem prevents words from being reduced. Only effective if a Language is
// specified.
	var noStem: Bool?

}

// CreateIndexRequest is the input object for CreateIndex.
struct CreateIndexRequest: Encodable, Decodable {

	// Index is the Index to create.
	var index: Any?

}

// CreateIndexResponse is the output object for CreateIndex.
struct CreateIndexResponse: Encodable, Decodable {

	// Index is the Index that was created.
	var index: Any?

	// Error is string explaining what went wrong. Empty if everything was fine.
	var error: String?

}

// DeleteDocRequest is the input object for DeleteDoc.
struct DeleteDocRequest: Encodable, Decodable {

	// IndexPath is the Index to delete from.
	var indexPath: String?

	// ID is the identifier of the document to delete.
	var id: String?

}

// DeleteDocResponse is the output object for DeleteDoc.
struct DeleteDocResponse: Encodable, Decodable {

	// Error is string explaining what went wrong. Empty if everything was fine.
	var error: String?

}

// DeleteIndexRequest is the input object for DeleteIndex.
struct DeleteIndexRequest: Encodable, Decodable {

	// IndexPath is the collection path in Firestore that identifies an Index.
	var indexPath: String?

}

// DeleteIndexResponse is the output object for DeleteIndex.
struct DeleteIndexResponse: Encodable, Decodable {

	// Error is string explaining what went wrong. Empty if everything was fine.
	var error: String?

}

// SearchField is a text field that can be searched.
struct SearchField: Encodable, Decodable {

	// Key is the name of the field.
	var key: String?

	// Value is the searchable text field.
	var value: String?

}

// Doc describes a document that can be searched.
struct Doc: Encodable, Decodable {

	// ID is the document identifier.
	var id: String?

	// Title is an optional string that is returned along with search results. Titles
// are not searchable. To make the Title searchable, you should explicitly add it
// to the Fields.
	var title: String?

	// SearchFields are the searchable fields for this document.
	var searchFields: Any?

	// FilterFields are the filterable fields for this document.
	var filterFields: Any?

}

// GetIndexRequest is the input object for GetIndex.
struct GetIndexRequest: Encodable, Decodable {

	// IndexPath is the collection path in Firestore that identifies an Index.
	var indexPath: String?

}

// GetIndexResponse is the output object for GetIndex.
struct GetIndexResponse: Encodable, Decodable {

	// Index is the Index that was created.
	var index: Any?

	// Error is string explaining what went wrong. Empty if everything was fine.
	var error: String?

}

// GetIndexesRequest is the input object for GetIndexes.
struct GetIndexesRequest: Encodable, Decodable {

}

// GetIndexesResponse is the output object for GetIndexes.
struct GetIndexesResponse: Encodable, Decodable {

	// Indexes are the indexes managed by this service.
	var indexes: Any?

	// Error is string explaining what went wrong. Empty if everything was fine.
	var error: String?

}

// Highlight describes an area that specifically matches a search query.
struct Highlight: Encodable, Decodable {

	// Field is the name of the field.
	var field: String?

	// Text is the highlighted text.
	var text: String?

	// Line is the line number where the match occurs.
	var line: Double?

}

// PutDocRequest is the input object for PutDoc.
struct PutDocRequest: Encodable, Decodable {

	// IndexPath is the Index to put a document to.
	var indexPath: String?

	// Doc is the document to put.
	var doc: Any?

}

// PutDocResponse is the output object for PutDoc.
struct PutDocResponse: Encodable, Decodable {

	// Error is string explaining what went wrong. Empty if everything was fine.
	var error: String?

}

// SearchQuery describes a search query.
struct SearchQuery: Encodable, Decodable {

	// IndexPath is the path of the index to search.
	var indexPath: String?

	// AccessKey authenticates the request. Get an AccessKey from the
// AccessKeyService.GenerateKey method.
	var accessKey: String?

	// Limit is the maximum number of search results to return. Smaller limits are
// faster.
	var limit: Double?

	// Text contains a phrase to search for.
	var text: String?

	// Filters are a list of where filters to apply when performing the search.
	var filters: Any?

	// Select lists the fields to get from the document. Filters are automatically
// included.
	var select: String?

	// SearchFields is a list of fields to search. If empty, all fields will be
// searched.
	var searchFields: String?

	// Cursor is a encoded string from a previous Query, that you can use to get more
// results.
	var cursor: String?

}

// SearchRequest is the input object for Search.
struct SearchRequest: Encodable, Decodable {

	// Query is the SearchQuery to perform.
	var query: Any?

}

// SearchResult is a document that matches a search query.
struct SearchResult: Encodable, Decodable {

	// ID is the document identifier.
	var id: String?

	// Title is an optional string that is returned along with search results. Titles
// are not searchable. To make the Title searchable, you should explicitly add it
// to the Fields.
	var title: String?

	// Fields are the selected fields for this document.
	var fields: Any?

	// Highlights describe areas within the text that specifically match the query.
	var highlights: Any?

	// Score is a relative value for this query. Higher score is better.
	var score: Double?

}

// SearchResponse is the output object for Search.
struct SearchResponse: Encodable, Decodable {

	// Query is the SearchQuery that generated these results.
	var query: Any?

	// Hits are the search results.
	var hits: Any?

	// Duration is the milliseconds that the search took to execute in the server side
	var duration: Double?

	// Cursor is a encoded string that you can pass to a new Query to get more results.
	var cursor: String?

	// More is false when there are not more search results, and true when the system
// thinks it could be more search results but is not warantee that the new query
// would return more results
	var more: Bool?

	// Error is string explaining what went wrong. Empty if everything was fine.
	var error: String?

}


struct OtoError: LocalizedError
{
	var errorDescription: String? { return message }
	var failureReason: String? { return message }
	var recoverySuggestion: String? { return "" }
	var helpAnchor: String? { return "" }

	private var message : String

	init(_ description: String) {
		message = description
	}
}
// Code generated by oto; DO NOT EDIT.

// Client provides access to remote services.
export class Client {
	// endpoint points to the Firesearch API.
	public endpoint: string = '/api'
	// apiKey is the secret API key to access the services.
	// This should only be used for backend to backend communication,
	// secret keys should never find their way into the browser.
	public apiKey: string = ''
	// fetch is the method to use to access remote
	// services.
	public fetch: any = null
	constructor(endpoint: string) {
		this.endpoint = endpoint
	}
}

<%= for (service) in def.Services { %>
<%= format_comment_text(service.Comment) %>export class <%= service.Name %> {
	constructor(readonly client: Client) {}
	<%= for (method) in service.Methods { %>
<%= format_comment_text(method.Comment) %>	async <%= method.NameLowerCamel %>(<%= camelize_down(method.InputObject.TypeName) %>?: <%= method.InputObject.TypeName %>): Promise<<%= method.OutputObject.TypeName %>> {
		if (<%= camelize_down(method.InputObject.TypeName) %> == null) {
			<%= camelize_down(method.InputObject.TypeName) %> = new <%= method.InputObject.TypeName %>();
		}
		const headers: any = {};
		if (this.client.apiKey) {
			headers['X-API-Key'] = this.client.apiKey;
		}
		headers['Accept'] = 'application/json';
		headers['Content-Type'] = 'application/json';
		if (this.client.fetch == null) {
			throw new Error(`<%= service.Name %>.<%= method.Name %>: no fetch (try client.fetch = window.fetch.bind(window))`)
		}
		const response = await this.client.fetch(this.client.endpoint + '/<%= service.Name %>.<%= method.Name %>', {
			method: 'POST',
			headers: headers,
			body: JSON.stringify(<%= camelize_down(method.InputObject.TypeName) %>),
		})
		if (response.status !== 200) {
			throw new Error(`<%= service.Name %>.<%= method.Name %>: ${response.status} ${response.statusText}`);
		}
		return response.json().then((json: any) => {
			if (json.error) {
				throw new Error(json.error);
			}
			return new <%= method.OutputObject.TypeName %>(json);
		})
	}
	<% } %>
}
<% } %>

<%= for (object) in def.Objects { %>
<%= format_comment_text(object.Comment) %>export class <%= object.Name %> {
	constructor(data?: any) {
		if (data) {
		<%= for (field) in object.Fields { %>
			<%= if (field.Type.IsObject) { %>
				<%= if (field.Type.Multiple) { %>
					if (data.<%= field.NameLowerCamel %>) {
						this.<%= field.NameLowerCamel %> = new Array<<%= field.Type.ObjectName %>>()
						for (let i = 0; i < data.<%= field.NameLowerCamel %>.length; i++) {
							this.<%= field.NameLowerCamel %>.push(new <%= field.Type.ObjectName %>(data.<%= field.NameLowerCamel %>[i]));
						}
					}
				<% } else { %>
					this.<%= field.NameLowerCamel %> = new <%= field.Type.ObjectName %>(data.<%= field.NameLowerCamel %>);
				<% } %>
			<% } else { %>
			this.<%= field.NameLowerCamel %> = data.<%= field.NameLowerCamel %>;
			<% } %>
		<% } %>
		}
	}
<%= for (field) in object.Fields { %>
	<%= format_comment_text(field.Comment) %>	<%= field.NameLowerCamel %><%= if (field.Type.IsObject || field.Type.Multiple) { %>?<% } %>: <%= if (field.Type.IsObject) { %><%= field.Type.TypeName %><%= if (field.Type.Multiple) { %>[]<% } %><% } else { %><%= field.Type.JSType %><%= if (field.Type.Multiple) { %>[]<% } %><%= if (!field.Type.Multiple) { %> = <%= field.Type.JSType %>Default<% } %><% } %>;
<% } %>
}
<% } %>

// these defaults make the template easier to write.
const stringDefault = ''
const numberDefault = 0
const booleanDefault = false 
const anyDefault = null
